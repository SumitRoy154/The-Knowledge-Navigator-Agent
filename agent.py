import logging
from langchain_google_genai import ChatGoogleGenerativeAI
from langchain.agents import AgentExecutor, create_tool_calling_agent
from langchain_core.prompts import ChatPromptTemplate
from langchain.tools import StructuredTool
from pydantic import BaseModel, Field

# Local imports
from config import GEMINI_API_KEY
from tools.course_finder import search_online_courses
from tools.roadmap_generator import generate_learning_roadmap

# Configure basic logging
logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')

# --- System Prompt Definition ---
SYSTEM_PROMPT = """
You are a friendly, formal, and resourceful Academic Advisor named the Knowledge Navigator.
Your tone is helpful, encouraging, and highly data-driven.
Your primary goal is to act as a comprehensive guide for users looking to learn a new topic.

**Agent Workflow:**
1.  When a user expresses a desire to learn about a broad topic (e.g., "I want to learn AI"), you MUST first use the `generate_learning_roadmap` tool to create a structured learning plan.
2.  After generating the roadmap, you MUST then immediately use the `search_online_courses` tool to find relevant beginner courses for that same topic.
3.  Finally, you must synthesize the information from both tools into a single, comprehensive response.

**Response Structure:**
- Start with a friendly introduction.
- Present the detailed, multi-phase learning roadmap generated by the tool.
- Present the course recommendations found by the search tool in a clear, structured format (like a table).
- Conclude with a helpful summary and next steps.

**Constraint Rules:**
- NEVER invent or hallucinate course data. Only use the exact data returned by the `search_online_courses` tool.
- If the search tool returns no results, you must still present the learning roadmap and then clearly state that you could not find any specific courses.
"""

# --- Pydantic Model for the Tool's Arguments ---
class CourseSearchArgs(BaseModel):
    topic: str = Field(description="The main subject or topic of the courses to search for.")
    max_price: float = Field(default=None, description="The maximum budget for the course in USD.")
    min_rating: float = Field(default=None, description="The minimum user rating for the course (e.g., 4.5).")

# --- Agent Class ---
class Agent:
    def __init__(self):
        # 1. Initialize the LLM
        # Configure the model with the API key and latest model name
        self.llm = ChatGoogleGenerativeAI(
            model="gemini-2.5-flash",
            google_api_key=GEMINI_API_KEY,
            temperature=0.7
        )

        # 2. Define the custom tools
        tools = [
            StructuredTool.from_function(
                func=generate_learning_roadmap,
                name="generate_learning_roadmap",
                description="Generates a structured, multi-phase learning roadmap for a given topic.",
            ),
            StructuredTool.from_function(
                func=search_online_courses,
                name="search_online_courses",
                description="Searches for online courses based on topic, budget, and rating preferences.",
                args_schema=CourseSearchArgs
            )
        ]

        # 3. Create the Agent Prompt Template
        prompt = ChatPromptTemplate.from_messages([
            ("system", SYSTEM_PROMPT),
            ("placeholder", "{chat_history}"),
            ("human", "{input}"),
            ("placeholder", "{agent_scratchpad}"),
        ])

        # 4. Create the Agent
        agent = create_tool_calling_agent(self.llm, tools, prompt)

        # 5. Create the Agent Executor
        self.executor = AgentExecutor(
            agent=agent, 
            tools=tools, 
            verbose=True, # Set to True to see agent's thought process
            handle_parsing_errors=True # Gracefully handle any LLM output errors
        )

    def format_response(self, response):
        """Format the agent's response to be clean and consistent."""
        # If the response is a list of courses, format it nicely
        if isinstance(response, list) and all(isinstance(item, dict) and 'course_name' in item for item in response):
            formatted = "\nHere are some recommended courses for you:\n"
            for i, course in enumerate(response, 1):
                formatted += f"\n{i}. {course['course_name']}"
                formatted += f"\n   Platform: {course['platform_name']}"
                formatted += f"\n   Price: {'Free' if course['price_usd'] == 0.0 else f'${course['price_usd']}'}"
                formatted += f"\n   Rating: {course['average_rating']}/5"
                formatted += f"\n   Duration: {course['duration_weeks']} weeks"
                formatted += f"\n   Link: {course['course_url']}\n"
            return formatted
            
        # For regular text responses, clean up formatting
        if isinstance(response, str):
            # Remove any color codes or special formatting
            import re
            response = re.sub(r'\x1b\[([0-9A-Za-z;?]?[0-9]*)*[m|K]?', '', response)
            
            # Clean up the response
            lines = [line.strip() for line in response.split('\n') if line.strip()]
            return '\n'.join(lines)
            
        return str(response)

    def invoke(self, user_input: str, chat_history: list):
        """Invokes the agent with user input and chat history, returning the response."""
        logging.info(f"Invoking agent with input: '{user_input}' and history: {len(chat_history)} messages")
        try:
            # Process the input
            response = self.executor.invoke({
                "input": user_input,
                "chat_history": [msg for msg in chat_history if not isinstance(msg, dict)]
            })
            
            full_response = response['output']
            formatted_response = self.format_response(full_response)
            
            # Store the response in the chat history
            chat_history.append({
                'user_input': user_input,
                'response': formatted_response
            })
                
            logging.info("Agent response formatted")
            return formatted_response
            
        except Exception as e:
            error_msg = f"I'm sorry, but I encountered an error: {str(e)}"
            logging.error(f"Error in agent invocation: {error_msg}")
            return error_msg

# Minimal fallback KnowledgeNavigatorAgent so main.py can import and run.
# This agent uses the live search tool (search_online_courses) to build a simple
# numbered response when a full LLM-based agent is not available.

import re
from typing import List
from tools.course_finder import search_online_courses

class KnowledgeNavigatorAgent:
    """Lightweight agent fallback that formats live search results into a numbered response."""

    def __init__(self):
        # No external LLM calls here — simple deterministic fallback.
        self.name = "KnowledgeNavigatorAgent (fallback)"

    def _extract_topic(self, text: str) -> str:
        t = (text or "").strip()
        l = t.lower()
        triggers = ["i want to learn", "want to learn", "learn", "study", "master", "explore"]
        for trig in triggers:
            if trig in l:
                idx = l.find(trig)
                rem = t[idx + len(trig):].strip(" :,-.?")
                if rem:
                    # return up to first 6 words as topic
                    return " ".join(rem.split()[:6])
        # fallback: first two words
        parts = t.split()
        return " ".join(parts[:2]) if parts else ""

    def _build_simple_response(self, topic: str, courses: List[dict]) -> str:
        topic_clean = topic.title() if topic else "Topic"
        lines = []
        # 1. Introduction
        lines.append("1. Introduction")
        lines.append(f"1.1 {topic_clean} is an excellent subject to dive into. It builds practical skills that are widely applicable.")
        lines.append("1.2 I searched the web for relevant beginner-friendly courses and structured them into a simple learning path.")
        lines.append("")
        # 2. Learning Path (simple fixed phases)
        lines.append(f"2. Learning Path: {topic_clean} Fundamentals")
        lines.append("2.1 Phase I: The Foundation")
        lines.append("2.1.1 Focus: Terminology and core mechanics")
        lines.append("2.1.2 Key Topics to Master: Core fundamentals, basic terminology and concepts")
        lines.append("2.1.3 Estimated Duration: 4-8 Weeks")
        lines.append("")
        lines.append("2.2 Phase II: Core Application")
        lines.append("2.2.1 Focus: Practical application and hands-on skills")
        lines.append("2.2.2 Key Topics to Master: Projects, applied techniques, workflows")
        lines.append("2.2.3 Estimated Duration: 6-10 Weeks")
        lines.append("")
        lines.append("2.3 Phase III: Analysis & Reporting")
        lines.append("2.3.1 Focus: Advanced topics and real-world scenarios")
        lines.append("2.3.2 Key Topics to Master: Advanced concepts, evaluation, deployment")
        lines.append("2.3.3 Estimated Duration: 8-12 Weeks")
        lines.append("")
        # 3. Top 3 Courses
        lines.append("3. Top 3 Courses to Start Your Journey")
        if not courses:
            lines.append("3.1 No courses found for this topic.")
        else:
            # prefer Phase I when present
            phase_one = [c for c in courses if c.get("phase") == "Phase I"]
            candidates = phase_one or sorted(courses, key=lambda x: x.get("rating", 0), reverse=True)
            top3 = sorted(candidates, key=lambda x: x.get("rating", 0), reverse=True)[:3]
            for i, c in enumerate(top3, start=1):
                name = c.get("name", "Unknown")
                platform = c.get("platform", "Unknown")
                focus = (c.get("focus") or c.get("key_topics") or "").replace("\n", " ")
                price = c.get("price", "Varies")
                rating = f"{float(c.get('rating')):.1f}" if c.get("rating") else "N/A"
                url = c.get("url", "N/A")
                lines.append(f"3.{i} Course Name: {name}")
                lines.append(f"3.{i}.1 Platform: {platform}")
                lines.append(f"3.{i}.2 Key Focus: {focus}")
                lines.append(f"3.{i}.3 Price (USD): {price}")
                lines.append(f"3.{i}.4 Rating: {rating}")
                lines.append(f"3.{i}.5 Link: {url}")
                lines.append("")
        # 4. Next steps
        lines.append("4. Next Steps")
        if courses:
            first = courses[0].get("name") if courses else "a recommended course"
            lines.append(f"4.1 Recommendation: Start with \"{first}\" for a strong foundation.")
            lines.append("4.2 Study focus: Work through Phase I material and practice with short exercises.")
        else:
            lines.append("4.1 I couldn't find suitable courses. Try refining your query.")
        return "\n".join(lines)

    def generate_response(self, user_input: str) -> str:
        """Public method expected by main.py — returns a plain text response."""
        topic = self._extract_topic(user_input)
        if not topic:
            return "Please tell me what you want to learn (for example: 'I want to learn accounting')."
        try:
            courses = search_online_courses(topic, level="Beginner", max_results=12)
        except Exception:
            courses = []
        return self._build_simple_response(topic, courses)
